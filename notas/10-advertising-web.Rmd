# Algoritmos para publicidad en línea

En esta parte discutimos algoritmos para el problema de colocación
de *search ads*, o anuncios relacionados a consultas web en buscadores.

Hay varios tipos de publicidad en línea. Algunos que **no** trataremos:


- **Anuncios de display**: estos se colocan en distintos sitios (editores o publishers) y son lo más parecido a la publicidad tradicional. Se cobran por impresiones (cuántas veces se mostró un anuncio de Coca a personas que entraron a la página del Universal, por ejemplo) y su propósito puede ser conseguir tráfico o ventas, aunque también comunmente se utilizan para mejorar la consideración o recordación de marca de algún producto.La colocación de estos anuncios se pueden decidir utilizando datos de los usuarios (qué sitios ha visto, qué intereses ha mostrado, etc). Aquí no discutiremos el tipos de algoritmos asociados a estos anuncios.

- Anuncios en tiendas como Amazon que son similares a recomendaciones.

- Discutiremos principalmente **search advertising**, donde tenemos:

1. Usuarios que hacen búsquedas en el buscador (por ejemplo, *navajas suizas*)
2. Anunciantes que quieren mostrar a su publicidad a los usuarios que hacen
ciertas búsquedas (por ejemplo, aquellos que quieren capturar búsquedas generales
de *navajas suizas* en México). Estos usuarios tienen presupuestos para pagar
por los clicks generados.
3. El buscador, que debe decidir qué anuncios mostrar a cada usuario dependiendo del pool de anunciantes que compiten por la búsqueda en particular (por ejemplo, quizá compite Vitorinox, Amazon, algunas tiendas on-line de campismo, etc).

## Algoritmos en línea

Una de las características prinicipales de los anuncios de búsqueda es que
la decisión de qué anuncios deben mostrarse deben hacerse en el momento de la búsqueda,
de manera *miope*. 

Veamos primero cómo resolveríamos el problema de manera retrospectiva:

- Supongamos que tenemos, para un mes dado, todas las búsquedas que incluyen
el término *navajas suizas* que se hicieron en el buscador.
- Ahora tenemos un grupo de anunciantes, y cada uno de ellos está dispuesto a pagar
una cantidad por cada click de sus anuncios. Adicionalmente, supongamos que sabemos el CTR (*clickthrough rate*) de cada uno de los anuncios considerados. A algunos de estos anunciantes les interesa el término general *navajas suizas*, pero quizá otros están interesados también en particular por *navajas suizas en México*. Puede ser que algunos anunciantes tengan restricciones regionales, otros no, etc.
- Adicionalmente, cada anunciante tiene un presupuesto máximo para un periodo dado. 
- Podríamos entonces **distribuir (optimizar) los anuncios a los usuarios** de manera que el ingreso del buscador por publicidad sea máximo, y todos los anunciantes terminen en o por debajo de presupuesto. 

Sin embargo, no podemos tomar la decisión de manera retrospectiva. Cada vez que se
hace una búsqueda, debemos decidir que anuncio poner, sin estar seguros de cuántas más
búsquedas de qué tipo vamos a ver en el futuro. 

#### Ejemplo{-}
Supongamos que tenemos dos anunciantes. El anunciante A ofrece 10 centavos por click 
para la búsqueda de "viajes a cancún". El anunciante B ofrece 20 centavos por click
en los términos "viajes a playa" y "viajes a cancún". Supongamos que ambos tienen un 
presupuesto de 100 dólares. 

Ahora supongamos que llega una búsqueda por "viajes a cancún". ¿A quién le damos
el anuncio? En primer lugar, podríamos decidir darle el espacio a B, que tiene la oferta
más alta por el término de búsqueda. Sin embargo, si hiciéramos esto podríamos
agotar las búsquedas de "viajes a cancún" y  el presupuesto de B, y después, cuando 
llegan búsquedas de "viajes a playa" 
(que suponemos más comunes), no tenemos inventario de anuncios (para un día dado, por ejemplo), y todo el presupuesto de A se quedaría sin gastar.

Sin embargo, su pudiéramos saber cuántas busquedas va a haber de cada término, podríamos
entonces compartir "viajes a cancún" entre A y B, sabiendo que el presupuesto restante
de B podemos usarlo después en el término "viajes a playa".

## El problema de matching

Consideremos primero una versión simplificada que queremos resolver: el problema
de "matching maximal", en donde tenemos una gráfica bipartita (dos conjuntos
de nodos, derecha e izquierda), y existen aristas conectando los dos grupos
de nodos.

En este caso, vemos los nodos del lado izquierdo como los *anunciantes*
y los nodos del lado izquierda las búsquedas o los *usuarios*:


```{r, out.width="400px", out.height="300px", fig.width=4, fig.height=4}
library(tidyverse)
library(ggraph)
library(tidygraph)
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
df_ejemplo <- data_frame(from = c(1,1,2,3,3,4), 
  to = c("a", "c", "b", "b", "d", "a"))
tipos <- data_frame(name=c(1:4,letters[1:4]), 
  type = c(rep(1,4), rep(0,4)))
grafica_df <- as_tbl_graph(df_ejemplo) %>%
  activate(nodes) %>% left_join(tipos)
positions <- data_frame(x = -c(0,1,2,3,0,1,2,3),
  y = c(0,0,0,0,1,1,1,1))
ggraph(grafica_df, "manual", node.positions = positions) + 
  geom_edge_link(edge_width = 1.5, colour="gray50") +
  geom_node_point() + coord_flip() + 
  geom_node_label(aes(label=name)) +
  theme_graph(fg_text_colour = 'white')
```


Las aristas de esta gráfica muestran cuales búsquedas son candidatas
para cada anunciante (que depende en primer lugar de los términos de la
búsqueda y los keywords para los que el anunciante hizo una oferta).

- Un **matching** es un subconjunto de las aristas de la gráfica bipartita.
- Un matching es **perfecto** si todos los nodos aparecen en el matching.
- Un matching es **maximal** cuando es tan grande (en número de nodos) como cualquier otro matching que se pueda encontrar.

#### Ejemplo {-}
En nuestro ejemplo, consideremos el siguiente matching:


```{r}
df_ejemplo <- data_frame(from = c(1,1,2,3,3,4), 
  to = c("a", "c", "b", "b", "d", "a"), in_matching = c(0,1,1,0,1,1))
tipos <- data_frame(name=c(1:4,letters[1:4]), 
  type = c(rep(1,4), rep(0,4)))

grafica_df <- as_tbl_graph(df_ejemplo) %>%
  activate(nodes) %>% left_join(tipos)
```


```{r, out.width="400px", out.height="300px", fig.width=6, fig.height=4}

ggraph(grafica_df, layout = 'manual', node.positions=positions) + 
  geom_edge_link(aes(colour=factor(in_matching)), edge_width=1.5) +
  geom_node_point() + coord_flip() + 
  geom_node_label(aes(label=name)) +
  theme_graph(fg_text_colour = 'white') +
  scale_edge_colour_manual(values=cbPalette)
```

Es un  matching perfecto, pues todos los nodos están pareados con algún otro.
Es también maximal, pues no podemos agregar aristas para tener un matching más grande.

Obsérvese también que es único matching perfecto para esta gráfica. Si empezamos
agregando (a,1), por ejemplo, no queda ningún candidato para c. Si conectármaos
(b,3), entonces tampoco quedarían candidatos para 2.

El siguiente matching no es perfecto, aunque sí es maximal:

```{r}
df_ejemplo <- data_frame(from = c(1,1,2,3,3,4), 
  to = c("a", "c", "b", "b", "d", "a"), in_matching = c(1,0,1,0,1,0))
tipos <- data_frame(name=c(1:4,letters[1:4]), 
  type = c(rep(1,4), rep(0,4)))

grafica_df <- as_tbl_graph(df_ejemplo) %>%
  activate(nodes) %>% left_join(tipos)
```



```{r, out.width="400px", out.height="300px", fig.width=6, fig.height=4}

ggraph(grafica_df, layout = 'manual', node.positions=positions) + 
  geom_edge_link(aes(colour=factor(in_matching)), edge_width=1.5) +
  geom_node_point() + coord_flip() + 
  geom_node_label(aes(label=name)) +
  theme_graph(fg_text_colour = 'white') +
  scale_edge_colour_manual(values=cbPalette)
```