# Pagerank y análisis de redes

## Introducción

**Pagerank** asigna un número real a cada página de una red (web). Este número es un indicador de su importancia. Las ideas fundamentales son: 

- Las páginas de internet forman una red o gráfica, donde los nodos son las páginas y las aristas dirigidas son las ligas de unas páginas a otras.
- La importancia de un página A depende de cuántas otras páginas apuntan a la página A. También depende de qué tan importantes sean las páginas que apuntan a A.
- Cuando hacemos una búsqueda, primero se filtran las páginas que tienen el contenido
de nuestra búsqueda, y después los resultados se ordenan según el pagerank
de estas páginas filtradas.
- ¿Qué problema resuelve? En un principio, se usaron métodos como índices y recuperación de documentos usando técnicas como tf-idf. El problema es que es muy fácil que un *spammer* sesgue los resultados para que sus páginas tengan alto nivel de relevancia en este sentido. Así que la importancia no se juzga sólo con el contenido,  sino de los *votos* de otras páginas importantes. Este es un sistema más difícil de engañar.

- Es crucial usar la importancia de los *in-links* de una página: si no, sería tambíen fácil crear muchas páginas spam que apunten a otra dada para aumentar
su importancia.

El *Pagerank*, más en general, es una medida de *centralidad* o *importancia* de los nodos de una red dirigida. Comenzaremos considerando redes más variadas (por ejemplo, redes sociales) y el concepto general de *centralidad*.

### Centralidad en redes 

Consideremos una red de personas, que representamos como una gráfica $G$ no dirigida. Las personas son los nodos y sus relaciones se representan con aristas no dirigidas.

Quiséramos construir una medida de importancia o centralidad de una persona dentro de la red. Por ejemplo:

- Redes sociales de internet: las ligas representan relación de *amigos*,
o la de *seguidor*.  Importancia: número de amigos o seguidores (grado de entrada o salida).
- Redes de citas bibliográficas: las ligas representan quién comparte o usa la información de quién. Importancia: número de citas o usos, ser citado por alguien importante, etc. 
- Red de empleados de una oficina: las ligas representan interacciones en algún periodo. Importancia: quién puede conectar de manera más inmediata a dos personas.


### Ejemplo de Moviegalaxies.com: Pulp Fiction {-}

 Dos personajes están ligados si tienen interacciones en la película. El tamaño y color de los nodos dependen de su "centralidad" en la red.

![Pulp fiction](./imagenes/pulpfiction.png)

(Gráfica creada con *Gephi*).

## Tipos de redes y su representación

Una red es un conjunto de *nodos* conectados por algunas *aristas*. 
Las aristas pueden ser 

- Dirigidas: hay un nodo origen y un nodo destino.
- No dirigidas: una arista representa una conexión simétrica entre dos nodos.

Podemos representar redes de varias maneras. Una primera manera
es con una lista de pares de *vértices* o *nodos* 
que están conectados por una *arista*. Por ejemplo, para una red dirigida:

```{r, fig.width=4, fig.asp=0.7, message = FALSE, warning = FALSE}
library(tidyverse)
library(tidygraph)
library(ggraph)
aristas <- data_frame(from = c(1, 1, 1, 1, 2), 
                      to =   c(2, 3, 4, 5, 3))
aristas
```

```{r}
red_tbl <- tidygraph::as_tbl_graph(aristas, directed = TRUE)
red_tbl
```

Que podemos visualizar como sigue:

```{r, fig.width = 6, fig.asp = 0.7}
graficar_red <- function(red_tbl){
  ggraph(red_tbl) + 
    geom_edge_link(arrow = arrow(), end_cap = circle(4, 'mm')) +
    geom_node_point(size = 10, colour = 'salmon') +
    geom_node_text(aes(label = name)) +
    theme_graph() + coord_fixed()
}
graficar_red(red_tbl)
```

También es posible representar una red mediante una **matriz de adyacencia**. 

La matriz de adyacencia para una red es la matriz $A$ tal que
$$A_{ij} = 1$$
si existe una arista de $i$ a $j$. En el caso dirigido, $A$ es una
matriz simétrica.

```{r}
matriz_ad <- igraph::get.adjacency(red_tbl)
matriz_ad
```

Es más conveniente representar estas matrices como matrices ralas,
como veremos más adelantes.

**Nota de R**: utilizamos el paquete *tidygraph* y **ggraph** para hacer manipulaciones de gráficas graficación. Estos paquetes son extensiones
del paquete  *igraph*, que es el que contiene los algoritmos de visualización, procesamiento
y resumen de redes.


## Visualización de redes

Existen varios algoritmos para visualizar redes que revelan distintos aspectos de su estructura (ver por ejemplo *?layout* en R, en el paquete igraph). 
Para examinar redes de tamaño relativamente
chico, el algoritmo de visualización es importante para determinar qué podemos
entender de la red.

Por ejemplo, aquí construimos una red aleatoria, y hacemos un *layout* de
nodos aleatorio:

```{r, fig.width = 6, fig.asp = 0.7}
set.seed(1234)
g <- play_erdos_renyi(n = 20, p = 0.1, directed = FALSE) %>% 
  as_tbl_graph()
ggraph(g, layout = 'randomly') +
  geom_edge_link() +
  geom_node_point(size = 2, colour = 'salmon') +
  theme_graph()
```

Y comparamos con un algoritmo basado en fuerzas.

```{r, fig.width = 6, fig.asp = 0.7}
ggraph(g, layout = 'kk') +
  geom_edge_link() +
  geom_node_point(size = 2, colour = 'salmon') +
  theme_graph()
```

```{block2, type='resumen'}
Los algoritmos basados en fuerzas para representar redes en 2 o 3 dimensiones se basan principalmente en la siguiente idea:

- Las aristas actúan como resortes, que no permiten que nodos ligados se alejen mucho
- Los nodos tienen fuerzas de repulsión entre ellos (la analogía física es de cargas elécricas), y también a veces de gravedad entre ellos.
- El algoritmo de representación intenta minimizar la energía de la configuración del sistema de atracciones y repulsiones.
```

Hay muchas variaciones de estos algoritmos, por ejemplo: *graphopt* en igraph, 
fruchtermann-rheingold, kamada-kawai, gem, escalamiento multidimensional, forceAtlas,
etc. Intenta mover los nodos de las siguiente gráfica para entender el funcionamiento
básico de estos algoritmos:



```{r}
library(visNetwork)
edges <- g %>% activate(edges) %>% as_data_frame
set.seed(13)
visNetwork(nodes = data_frame(id = 1:20, label = 1:20), 
           edges, 
           width = "100%") %>%
  visPhysics(solver ='forceAtlas2Based')
```


### Ejercicio
- Para la gráfica anterior, intenta usar los algoritmos *kk* o *fr*. Busca qué parámetros
puedes cambiar en el algoritmo y experimenta cambiándolos (cuánta repulsión, rigidez
de los resortes, número de iteraciones, etc.)


Otras familias de algoritmos intentan distintas estrategias, como los layout
de círculo, estrella, para árboles, etc.

```{r, fig.width = 6, fig.asp = 0.7}
ggraph(g, layout = 'circle') +
  geom_edge_link() +
  geom_node_point(size = 2, colour = 'salmon') +
  theme_graph()
```

## Medidas de centralidad para redes

Como discutimos arriba, las medidas de centralidad en redes intenta capturar
un concepto de importancia o conectividad de un nodo en una red. Primero comenzamos
con el caso **no dirigido**. Medidas básicas de centralidad son


- **Grado** o grado de entrada/salida: cuántas ligas tiene un nodo (no dirigidos, de entrada o de salida). 

- **Betweeness**: qué tan importante o única es un nodo para conectar otras dosnodos de la red (por ejemplo, una persona con betweeness alto controla más fácilmente el flujo de información en una red social). 
- **Cercanía**: qué tan lejos en promedio están los otros nodos de la red (pues puede encontrar y conectar más fácilmente otras dos en la red).

- **Centralidad de eigenvector/Pagerank**: la centralidad de un nodo es una especie de promedio de la centralidad de sus vecinos, lo cual es una definición apartentemente circular.

### Grado

Sea $G$ una gráfica **no dirigida**, y sea $A$ la matriz de adyacencia de $G$
Si $i$ es un nodo (vértice) dado, entonces su grado es

$$c_G(i)=\sum_{j\leq i} A_{i,j}.$$
que cuenta cúantas aristas conectan con el nodo $i$.

```{r}
g_grado <- g %>% activate(nodes) %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre = 1:20) 
ggraph(g_grado, layout = 'kk') +
  geom_edge_link() +
  geom_node_point(aes(size = importancia), colour = 'salmon') +
  geom_node_text(aes(label = nombre)) +
  theme_graph()
```


#### ¿Qué no captura el grado como medida de centralidad? {-}

```{block2, type='resumen'}
El **grado** es una medida local que no toma en cuenta la topología de la red, que
puede indicar que un nodo es importante más allá de la incidencia local de aristas
```

#### Distancia a otros nodos {-}

En primer lugar, por ejemplo, no captura que algunos nodos están más cercanos en 
promedio a los nodos de la red que otros.

```{r}
g_simple <- igraph::graph(c(1, 2, 2, 3, 3, 4, 4, 5), directed = FALSE) %>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre  = LETTERS[1:5])

ggraph(g_simple) +
  geom_edge_link() +
  geom_node_point(aes(size = importancia), colour = 'salmon') +
  geom_node_text(aes(label = nombre)) +
  theme_graph(base_family = 'sans')
```

Obsérvese en este ejemplo que el nodo $C$ es más importante que $D$, en el sentido
de que está más cercano a los nodos de toda la red, aún cuando el grado es el mismo
para ambos.


#### Caminos que pasan por un nodo {-}

En la siguiente gráfica, el nodo $G$ es importante porque es la única conexión
entre dos partes de la red, y esto no lo captura el grado:

```{r}
triangulo_1 <- c(1,2,2,3,3,1)
triangulo_2 <- triangulo_1 + 3
red_3 <- igraph::graph(c(triangulo_1, triangulo_2, c(7,1,7,4)), directed = FALSE) %>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre  = LETTERS[1:7])

ggraph(red_3) +
  geom_edge_link() +
  geom_node_point(aes(size = importancia), colour = 'salmon') +
  geom_node_text(aes(label = nombre), nudge_y = 0.2) +
  theme_graph(base_family = 'sans')
```

#### Nodos conectados a otros nodos importantes {-}

En la siguiente gráfica el nodo $H$ tienen el mismo grado que $F$, pero
$H$ está conectado a un nodo más importante ($A$)
```{r}
red_4 <- igraph::graph(c(2,1,3,1,4,1,5,1,2,3,6,2,1,7,1,8), directed=FALSE)%>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre  = LETTERS[1:8])

ggraph(red_4) +
  geom_edge_link() +
  geom_node_point(aes(size = importancia), colour = 'salmon') +
  geom_node_text(aes(label = nombre), nudge_y = 0.2) +
  theme_graph(base_family = 'sans')
```


### Medida de centralidad: *Betweeness*.

La medida de centralidad *betweeness* de un nodo $i$ se define como:
$$c_b (i) = \sum_{j<k, j,k\neq i} g_{jk} (i) / g_{jk},$$
donde 
$g_{jk}$ es el número de caminos más cortos distintos entre $j$ y $k$ y 
$g_{jk}(i)$ es el número de caminos más cortos distintos entre $j$ y $k$ que pasan por $i$. 

- Los caminos que más aportan al betweeness de un nodo $i$ son los que no tienen otra alternativa más que pasar por $i$.

Esta medida se puede normalizar poniendo ($n$ es el total de nodos de la red)
$$\overline{c}_b (i)=c_b (i)/\binom{n-1}{2},$$
pues el denominador es el máximo valor de betweeness que puede alcanzar un vértice
en una red de $n$ nodos. 

*Betweenness*: ejemplo

```{r, tidy=FALSE, dev='pdf', fig.width=4, fig.height=3}
red_4 <- igraph::graph(c(2,1,3,1,4,1,5,1,2,3,6,2,2,5,1,6,6,7), directed = FALSE) %>% 
  as_tbl_graph() %>%
  mutate(betweeness = centrality_betweenness()) %>%
  mutate(nombre  = LETTERS[1:7])
ggraph(red_4) +
  geom_edge_link() +
  geom_node_point(aes(size = betweeness), colour = 'salmon') +
  geom_node_text(aes(label = nombre), nudge_y = 0.2) +
  theme_graph(base_family = 'sans')
red_4 %>% activate(nodes) %>% as_data_frame
```

Por ejemplo: para el nodo $B$, de dos posibles,
hay un camino más corto de 6 a 3 que pasa por 2 (aporta 0.5), igual entre
5 y 6 y entre 3 y 5, para un total de 1.5. Los demás caminos más cortos
(por ejemplo, entre 4 y 5) no aportan nada pues ninguno de ellos pasa por 2.
Calcula el *betweeness* para el nodo $F$ y $D$.


#### Ejemplo de grado y betweeness: Pulp Fiction {-}

En esta red, el color es una medición de betweeness y el tamaño el grado.
Aunque Butch y Jules tienen grados similares, Butch tiene *betweeness* más alto
pues provee más ligas únicas más cortas 
entre los personajes (mientras que la mayoría de los de Jules
pasan también por Vincent).

![Pulp fiction](./imagenes/pulp_fiction_between.png)


### Medida de centralidad: Cercanía

También es posible definir medidas de importancia según el promedio de cercanía a todos
los nodos: el inverso del promedio de distancias del nodo a todos los demás.

En el siguiente ejemplo, el nodo 6 tiene grado bajo, *betweeness* bajo, pero tiene buena
cercanía promedio, pues se conecta a un nodo bien conectado de la red (en grado y betweeness):
```{r}
red_5 <- igraph::graph(c(2,1,3,1,4,9,5,2,2,3,6,1,7,8,
                 8,9,9,1,1,8,1,7), 
               directed = FALSE)
igraph::closeness(red_5)
```
```{r, fig.height=2, fig.width=6, dev='pdf'}
par(mar=c(0,0,0,0)); plot(red_5, vertex.size=30, vertex.label.cex=0.6)
```


### Centralidad de eigenvector

Esta medida considera que la importancia de un nodo está dado por una suma de las
importancias de sus vecinos. De esta forma, es importante estar cercano a nodos importantes (como en cercanía), pero también cuenta conectarse a muchos nodos (como en grado).

- Nótese que esta es una descripción circular: para saber la importancia de un nodo, hay que saber la importancia de sus vecinos.

Consideremos el ejemplo siguiente:


```{r, fig.height=3, fig.width=3, dev='pdf'}
red.6 <- graph(c(1,2,1,3,1,4,5,2), directed = FALSE)
par(mar=c(0,0,0,0))
plot(red.6, vertex.size=40)
```

Supongamos que las importancias  de estos 5 nodos son
$$(x_1,\ldots, x_5)$$
donde $x_i\geq 0$.  Suponemos además que consideramos las importancias
normalizadas, es decir,
$$\sum_i x_i = 1.$$

Por ejemplo, en una red con un solo nodo, este nodo tiene importancia 1, una con dos
nodos conectados (o no conectados) debe tener $(1/2,1/2)$ como importancias.

De acuerdo a la idea mencionada arriba, calculamos entonces como se ve la suma de las importancias de nodos adyacentes a cada nodo. Para el nodo uno,

$$y_1 = x_2 + x_3 + x_4$$

para el nodo 2

$$y_2 = x_1 + x_5$$

y para los siguientes nodos tendríamos
$$y_3 = x_1$$
$$y_4 = x_1$$
$$y_5 = x_2$$.

Este sistema lo podemos escribir de forma matricial, usando
la matriz de adyacencia, como

\[ y = 
\left (
\begin{array}{rrrrr}
 0 & 1 & 1 & 1 & 0 \\ 
 1 & 0 & 0 & 0 & 1 \\ 
  1 & 0 & 0 & 0 & 0 \\ 
  1 & 0 & 0 & 0 & 0 \\ 
  0 & 1 & 0 & 0 & 0 \\ 
\end{array}
\right ) x
\]


**Por definición de las importancias**, si normalizamos este vector debemos obtener las importancias originales:

$$x = (x_1,\ldots, x_5)={\frac{1}{\lambda}}(y_1,\ldots,y_5)=\frac{1}{\lambda}y$$

Si reescribimos estas dos ecuaciones, tenemos que $x\geq 0$ debe satisfacer ($A$ es simétrica):
$$A^t x = \lambda x,$$

es decir, $x$ es un vector propio de la matriz de adyacencia con valor propio positivo.

Sin embargo, ¿cuando existe un vector $x\geq 0$ con $\lambda>0$ que satisfaga esta propiedad?

### Perron Frobenius: Centralidad de eigenvector 

El método se fundamenta en una versión del teorema de Perron-Frobenius:

### Perron-Frobenius {#importante}
Si $A$ es una matriz no negativa,  entonces:

- existe un valor
propio real *no-negativo* $\lambda_0$ tal que $\lambda_0\geq |\lambda|$ para cualquier otro valor propio $\lambda$ de A^t. 
- Al valor propio $\lambda_0$ está asociado a un vector propio $x$ con entradas no negativas. 

###

Si este vector propio fuera único, entonces esto nos daría un conjunto de medidas (únicas hasta normalización) $x$ para la importancia de los nodos.
Por el momento, es posible que haya más de una manera de asignar importancias.

### Ejemplo 1

```{r, dev='pdf', fig.width=2, fig.height=1, message=FALSE}
red <- graph(c(1,2,2,3,3,1,2,4), directed = FALSE)
par(mar=c(0,0,0,0)); plot(red, vertex.size=40)
A.red <- get.adjacency(red)
A.red
```



Ejemplo 1

```{r}
desc.A <- eigen(A.red)
desc.A
```




Las medida de centralidad da entonces, en este caso:

```{r, dev='pdf', fig.width=2, fig.height=1}
x <- -desc.A$vectors[,1]
x
par(mar=c(0,0,0,0)); plot(red, vertex.size  = 100*x)
```


### Ejemplo 2 {#ejemplo}

Cuando la gráfica no es conexa, encontramos más de un eigenvector no negativo:


```{r, dev='pdf', fig.width=2, fig.height=1, message=FALSE}
red <- graph(c(1,2,2,3,3,1,2,4,5,6), directed = FALSE)
par(mar=c(0,0,0,0)); plot(red, vertex.size=50)
A.red <- get.adjacency(red)
A.red
```



Nótese que los eigenvectores 1 y 2 son positivos, y están asociados a 
vectores propios no negativos:
```{r}
desc.A <- eigen(A.red)

desc.A
```

En este caso, la medida de centralización dependería de qué
peso le ponemos al primer vector propio vs el segundo vector propio

### Perron Frobenius: matrices irreducibles (no dirigido, matriz simétrica)

¿Cuándo podemos garantizar unicidad en la solución de $Ax=\lambda x$ con $\lambda >0$.
Sea $A$ la matriz de adyacencia de una gráfica no dirigida.

-  Si la gráfica asociada a $A$ es conexa (existen caminos entre cualquier par de vértices) entonces decimos que $A$ es **irreducible**.

- Si $A$ es irreducible, entonces $\lambda_0 > 0$ es un eigenvector simple de A, un vector propio asociado $x$ tiene entradas positivas, y no existe ningún otro vector propio con entradas no negativas que no sea paralelo a $x$

- Podemos definir una medida única de centralidad módulo una constante multiplicativa.

### Definición: Centralidad de Eigenvector {#importante}

Si $A$ es la matriz de adyacencia de una red no dirigida, y $A$ es irreducible, definimos
la **centralidad de eigenvector** de un nodo $i$ como la $i$-esima componente
del vector positivo $x$ (con $\sum x_i = 1$)
asociado al valor propio (único) de Perron-Frobenius. 


### Ejemplo: facultad de tres universidades

```{r}
library("igraphdata")
data("UKfaculty")
ukf.und <- as.undirected(UKfaculty) 
head(dat.1 <- get.data.frame((ukf.und)))
dat.1$from <- dat.1$from - 1
dat.1$to <- dat.1$to - 1
grupo <- get.vertex.attribute(UKfaculty, 'Group')
nodos <- data.frame(nombre=1:length(grupo), grupo=grupo)
nodos$nombre <- factor(nodos$nombre)

forceNetwork(dat.1, nodos, Source='from',Target='to',NodeID='nombre',
             Group='grupo', opacity=0.9, Value='weight', charge=-400,
             linkWidth = "function(d) { return 0.2*Math.sqrt(d.value); }")
```



Ahora calculamos centralidad de eigenvector.

```{r}
A <- get.adjacency(ukf.und)
e.A <- eigen(as.matrix(A))
vec <- as.numeric(e.A$vector[,1])
e.A$values[1]
qplot(vec)
```
```{r}
grupo <- -vec
nodos <- data.frame(nombre=1:length(grupo), grupo=grupo)
nodos$nombre <- factor(nodos$nombre)
forceNetwork(dat.1, nodos, Source='from',Target='to',NodeID='nombre',
             Group='grupo', opacity=0.9, Value='weight', charge=-1000,
             linkWidth = "function(d) { return 0.2*Math.sqrt(d.value); }",
             colourScale ='d3.scale.linear().domain([0, 0.15, 0.35]).range(["lightblue", "orange", "red"])')
```


### Ejercicio {#ejemplo}

Usa Gephi para calcular la centralidad de eigenvector/betweeness de tu red de amigos (es no dirigida).

- Bajar tu red: http://snacourse.com/getnet
- Gephi: https://gephi.org

