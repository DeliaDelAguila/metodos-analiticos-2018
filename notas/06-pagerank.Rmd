# Pagerank y análisis de redes

## Introducción

**Pagerank** asigna un número real a cada página de una red (web). Este número es un indicador de su importancia. Las ideas fundamentales son: 

- Las páginas de internet forman una red o gráfica, donde los nodos son las páginas y las aristas dirigidas son las ligas de unas páginas a otras.
- La importancia de un página A depende de cuántas otras páginas apuntan a la página A. También depende de qué tan importantes sean las páginas que apuntan a A.
- Cuando hacemos una búsqueda, primero se filtran las páginas que tienen el contenido
de nuestra búsqueda, y después los resultados se ordenan según el pagerank
de estas páginas filtradas.
- ¿Qué problema resuelve? En un principio, se usaron métodos como índices y recuperación de documentos usando técnicas como tf-idf. El problema es que es muy fácil que un *spammer* sesgue los resultados para que sus páginas tengan alto nivel de relevancia en este sentido. Así que la importancia no se juzga sólo con el contenido,  sino de los *votos* de otras páginas importantes. Este es un sistema más difícil de engañar.

- Es crucial usar la importancia de los *in-links* de una página: si no, sería tambíen fácil crear muchas páginas spam que apunten a otra dada para aumentar
su importancia.

El *Pagerank*, más en general, es una medida de *centralidad* o *importancia* de los nodos de una red dirigida. Comenzaremos considerando redes más variadas (por ejemplo, redes sociales) y el concepto general de *centralidad*.

### Centralidad en redes 

Consideremos una red de personas, que representamos como una gráfica $G$ no dirigida. Las personas son los nodos y sus relaciones se representan con aristas no dirigidas.

Quiséramos construir una medida de importancia o centralidad de una persona dentro de la red. Por ejemplo:

- Redes sociales de internet: las ligas representan relación de *amigos*,
o la de *seguidor*.  Importancia: número de amigos o seguidores (grado de entrada o salida).
- Redes de citas bibliográficas: las ligas representan quién comparte o usa la información de quién. Importancia: número de citas o usos, ser citado por alguien importante, etc. 
- Red de empleados de una oficina: las ligas representan interacciones en algún periodo. Importancia: quién puede conectar de manera más inmediata a dos personas.


### Ejemplo de Moviegalaxies.com: Pulp Fiction {-}

 Dos personajes están ligados si tienen interacciones en la película. El tamaño y color de los nodos dependen de su "centralidad" en la red.

![Pulp fiction](./imagenes/pulpfiction.png)

(Gráfica creada con *Gephi*).

## Tipos de redes y su representación

Una red es un conjunto de *nodos* conectados por algunas *aristas*. 
Las aristas pueden ser 

- Dirigidas: hay un nodo origen y un nodo destino.
- No dirigidas: una arista representa una conexión simétrica entre dos nodos.

Podemos representar redes de varias maneras. Una primera manera
es con una lista de pares de *vértices* o *nodos* 
que están conectados por una *arista*. Por ejemplo, para una red dirigida:

```{r, fig.width=4, fig.asp=0.7, message = FALSE, warning = FALSE}
library(tidyverse)
library(tidygraph)
library(ggraph)
aristas <- data_frame(from = c(1, 1, 1, 1, 2), 
                      to =   c(2, 3, 4, 5, 3))
aristas
```

```{r}
red_tbl <- tidygraph::as_tbl_graph(aristas, directed = TRUE)
red_tbl
```

Que podemos visualizar como sigue:

```{r, fig.width = 6, fig.asp = 0.7}
graficar_red_dirigida <- function(red_tbl){
  ggraph(red_tbl) + 
    geom_edge_link(arrow = arrow(), end_cap = circle(4, 'mm')) +
    geom_node_point(size = 10, colour = 'salmon') +
    geom_node_text(aes(label = name)) +
    theme_graph() + coord_fixed()
}
graficar_red_dirigida(red_tbl)
```

También es posible representar una red mediante una **matriz de adyacencia**. 

La matriz de adyacencia para una red es la matriz $A$ tal que
$$A_{ij} = 1$$
si existe una arista de $i$ a $j$. En el caso dirigido, $A$ es una
matriz simétrica.

```{r}
matriz_ad <- igraph::get.adjacency(red_tbl)
matriz_ad
```

Es más conveniente representar estas matrices como matrices ralas,
como veremos más adelantes.

**Nota de R**: utilizamos el paquete *tidygraph* y **ggraph** para hacer manipulaciones de gráficas graficación. Estos paquetes son extensiones
del paquete  *igraph*, que es el que contiene los algoritmos de visualización, procesamiento
y resumen de redes.


## Visualización de redes

Existen varios algoritmos para visualizar redes que revelan distintos aspectos de su estructura (ver por ejemplo *?layout* en R, en el paquete igraph). 
Para examinar redes de tamaño relativamente
chico, el algoritmo de visualización es importante para determinar qué podemos
entender de la red.

Por ejemplo, aquí construimos una red aleatoria, y hacemos un *layout* de
nodos aleatorio:

```{r, fig.width = 6, fig.asp = 0.7}
set.seed(1234)
g <- play_erdos_renyi(n = 20, p = 0.1, directed = FALSE) %>% 
  as_tbl_graph()
ggraph(g, layout = 'randomly') +
  geom_edge_link() +
  geom_node_point(size = 2, colour = 'salmon') +
  theme_graph()
```

Y comparamos con un algoritmo basado en fuerzas.

```{r, fig.width = 6, fig.asp = 0.7}
ggraph(g, layout = 'kk') +
  geom_edge_link() +
  geom_node_point(size = 2, colour = 'salmon') +
  theme_graph()
```

```{block2, type='resumen'}
Los algoritmos basados en fuerzas para representar redes en 2 o 3 dimensiones se basan principalmente en la siguiente idea:

- Las aristas actúan como resortes, que no permiten que nodos ligados se alejen mucho
- Los nodos tienen fuerzas de repulsión entre ellos (la analogía física es de cargas elécricas), y también a veces de gravedad entre ellos.
- El algoritmo de representación intenta minimizar la energía de la configuración del sistema de atracciones y repulsiones.
```

Hay muchas variaciones de estos algoritmos, por ejemplo: *graphopt* en igraph, 
fruchtermann-rheingold, kamada-kawai, gem, escalamiento multidimensional, forceAtlas,
etc. Intenta mover los nodos de las siguiente gráfica para entender el funcionamiento
básico de estos algoritmos:



```{r}
library(visNetwork)
edges <- g %>% activate(edges) %>% as_data_frame
set.seed(13)
visNetwork(nodes = data_frame(id = 1:20, label = 1:20), 
           edges, 
           width = "100%") %>%
  visPhysics(solver ='forceAtlas2Based')
```


### Ejercicio
- Para la gráfica anterior, intenta usar los algoritmos *kk* o *fr*. Busca qué parámetros
puedes cambiar en el algoritmo y experimenta cambiándolos (cuánta repulsión, rigidez
de los resortes, número de iteraciones, etc.)


Otras familias de algoritmos intentan distintas estrategias, como los layout
de círculo, estrella, para árboles, etc.

```{r, fig.width = 6, fig.asp = 0.7}
ggraph(g, layout = 'circle') +
  geom_edge_link() +
  geom_node_point(size = 2, colour = 'salmon') +
  theme_graph()
```

## Medidas de centralidad para redes

Como discutimos arriba, las medidas de centralidad en redes intenta capturar
un concepto de importancia o conectividad de un nodo en una red. Primero comenzamos
con el caso **no dirigido**. Medidas básicas de centralidad son


- **Grado** o grado de entrada/salida: cuántas ligas tiene un nodo (no dirigidos, de entrada o de salida). 

- **Betweeness**: qué tan importante o única es un nodo para conectar otras dosnodos de la red (por ejemplo, una persona con betweeness alto controla más fácilmente el flujo de información en una red social). 
- **Cercanía**: qué tan lejos en promedio están los otros nodos de la red (pues puede encontrar y conectar más fácilmente otras dos en la red).

- **Centralidad de eigenvector/Pagerank**: la centralidad de un nodo es una especie de promedio de la centralidad de sus vecinos.

### Grado

Sea $G$ una gráfica **no dirigida**, y sea $A$ la matriz de adyacencia de $G$
Si $i$ es un nodo (vértice) dado, entonces su grado es

$$c_G(i)=\sum_{j\leq i} A_{i,j}.$$
que cuenta cúantas aristas conectan con el nodo $i$.

```{r}
graficar_red_nd <- function(dat_g){
  ggraph(dat_g, layout = 'kk') +
  geom_edge_link() +
  geom_node_point(aes(size = importancia), colour = 'salmon') +
  geom_node_text(aes(label = nombre), nudge_y = 0.2) +
  theme_graph(base_family = 'sans')
}

g_grado <- g %>% activate(nodes) %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre = 1:20) 

graficar_red_nd(g_grado)
```


#### ¿Qué no captura el grado como medida de centralidad? {-}

```{block2, type='resumen'}
El **grado** es una medida local que no toma en cuenta la topología más global
de la red: cómo están conectados nodos más lejanos alrededor del nodo que nos interesa.
```

#### Distancia a otros nodos {-}

En primer lugar, por ejemplo, no captura que algunos nodos están más cercanos en 
promedio a los nodos de la red que otros.

```{r}
g_simple <- igraph::graph(c(1, 2, 2, 3, 3, 4, 4, 5), directed = FALSE) %>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre  = LETTERS[1:5])
graficar_red_nd(g_simple)
```

Obsérvese en este ejemplo que el nodo $C$ es más importante que $D$, en el sentido
de que está más cercano a los nodos de toda la red, aún cuando el grado es el mismo
para ambos.


#### Caminos que pasan por un nodo {-}

En la siguiente gráfica, el nodo $G$ es importante porque es la única conexión
entre dos partes de la red, y esto no lo captura el grado:

```{r}
triangulo_1 <- c(1,2,2,3,3,1)
triangulo_2 <- triangulo_1 + 3
red_3 <- igraph::graph(c(triangulo_1, triangulo_2, c(7,1,7,4)), directed = FALSE) %>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre  = LETTERS[1:7])
graficar_red_nd(red_3)
```

#### Nodos conectados a otros nodos importantes {-}

En la siguiente gráfica el nodo $H$ tienen el mismo grado que $F$, pero
$H$ está conectado a un nodo más importante ($A$)
```{r}
red_4 <- igraph::graph(c(2,1,3,1,4,1,5,1,2,3,6,2,1,7,1,8), directed=FALSE) %>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_degree()) %>%
  mutate(nombre  = LETTERS[1:8])
graficar_red_nd(red_4)
```


### Medida de centralidad: *Betweeness*.

La medida de centralidad *betweeness* de un nodo $i$ se define como:
$$c_b (u) = \sum_{j<k, u\neq j,u\neq i} g(j,k |u) / g(j,k),$$
donde

- $g(j,k)$ es el número de caminos más cortos distintos entre $j$ y $k$ y 
- $g(j,k |i)$ es el número de caminos más cortos distintos entre $j$ y $k$ que pasan por $i$. 
- $g(j,k | i ) = 0$ cuando $j=i$ o $k=i$.

- Los caminos que más aportan al betweeness de un nodo $i$ son los que no tienen otra alternativa más que pasar por $i$.

Esta medida se puede normalizar poniendo ($n$ es el total de nodos de la red)
$$\overline{c}_b (i)=c_b (i)/\binom{n-1}{2},$$
pues el denominador es el máximo valor de betweeness que puede alcanzar un vértice
en una red de $n$ nodos. 

#### Ejemplo {-}

```{r, fig.width=4, align='center'}
red_4 <- igraph::graph(c(2,1,3,1,4,1,5,1,2,3,6,2,2,5,1,6,6,7), directed = FALSE) %>% 
  as_tbl_graph() %>%
  mutate(importancia = centrality_betweenness()) %>%
  mutate(nombre  = LETTERS[1:7])
graficar_red_nd(red_4) + labs(subtitle = 'Betweeness')
```

Por ejemplo: para el nodo $B$, de dos posibles,
hay un camino más corto de 6 a 3 que pasa por 2 (aporta 0.5), igual entre
5 y 6 y entre 3 y 5, para un total de 1.5. Los demás caminos más cortos
(por ejemplo, entre 4 y 5) no aportan nada pues ninguno de ellos pasa por 2.
Calcula el *betweeness* para el nodo $B$ y $D$.

```{r}
red_4 %>% as_data_frame
```

#### Ejemplo de grado y betweeness: Pulp Fiction {-}

En esta red, el color es una medición de betweeness y el tamaño el grado.
Aunque Butch y Jules tienen grados similares, Butch tiene *betweeness* más alto
pues provee más ligas únicas más cortas 
entre los personajes (mientras que la mayoría de los de Jules
pasan también por Vincent).

![Pulp fiction](./imagenes/pulp_fiction_between.png)


### Medida de centralidad: Cercanía

También es posible definir medidas de importancia según el promedio de cercanía a todos
los nodos: el inverso del promedio de distancias del nodo a todos los demás.

#### Ejemplo {-}
```{r}
red_5 <- igraph::graph(c(2,1,3,1,4,9,5,2,2,3,6,1,7,8,
                 8,9,9,1,1,8,1,7), 
               directed = FALSE)
```

```{r}
red_5 <- red_5 %>% as_tbl_graph() %>%
  mutate(importancia = centrality_closeness(normalized = TRUE)) %>%
  mutate(nombre  = LETTERS[1:9])
red_5 %>% activate(nodes) %>% as_data_frame
graficar_red_nd(red_5) + labs(subtitle = 'Cercanía')
```
En este ejemplo, el nodo $F$ tiene cercanía más alta que $D$, por ejemplo,
pues se conecta a un nodo bien conectado de la red (en grado y betweeness):

#### Ejercicio {-}
Verifica que la cercanía de $A$ es 0.80.

### Centralidad de eigenvector

Esta medida considera que la importancia de un nodo está dado por una suma de las
importancias de sus vecinos. De esta forma, es importante estar cercano a nodos importantes (como en cercanía), pero también cuenta conectarse a muchos nodos (como en grado).

- Nótese que esta es una descripción circular: para saber la importancia de un nodo, hay que saber la importancia de sus vecinos.

Consideremos el ejemplo siguiente:


```{r, fig.height=3}
red_6 <- igraph::graph(c(1,2,1,3,1,4,5,2), directed = FALSE) %>%
  as_tbl_graph() %>% mutate(nombre = 1:5, importancia = 0)
graficar_red_nd(red_6) + theme(legend.position="none")
```

Supongamos que las importancias  de estos 5 nodos son
$$(x_1,\ldots, x_5)$$
donde $x_i\geq 0$.  Suponemos además que consideramos las importancias
normalizadas, es decir,
$$\sum_i x_i = 1.$$

Por ejemplo, en una red con un solo nodo, este nodo tiene importancia 1, una con dos
nodos conectados  debe tener $(1/2,1/2)$ como importancias.

De acuerdo a la idea mencionada arriba, calculamos entonces cómo se ve la suma de las importancias de nodos adyacentes a cada nodo. Para el nodo uno,

$$\frac{y_1}{\lambda} = x_2 + x_3 + x_4$$

donde $\lambda = \sum_i  y_i$ es la constante de normalización. También podemos
escribir como

$${y_1} = \lambda(x_2 + x_3 + x_4)$$


para el nodo 2 (despejando $\lambda$)

$$y_2 = \lambda(x_1 + x_5)$$

y para los siguientes nodos tendríamos
$$y_3 = \lambda x_1$$
$$y_4 = \lambda x_1$$
$$y_5 = \lambda x_2$$.

Este sistema lo podemos escribir de forma matricial, usando
la matriz de adyacencia, como

\[ y = 
\lambda \left (
\begin{array}{rrrrr}
 0 & 1 & 1 & 1 & 0 \\ 
 1 & 0 & 0 & 0 & 1 \\ 
  1 & 0 & 0 & 0 & 0 \\ 
  1 & 0 & 0 & 0 & 0 \\ 
  0 & 1 & 0 & 0 & 0 \\ 
\end{array}
\right ) x
\]


**Por definición de las importancias**, si normalizamos este vector debemos obtener las importancias originales:

$$x = (x_1,\ldots, x_5)={\frac{1}{\lambda}}(y_1,\ldots,y_5)=\frac{1}{\lambda}y$$

Si reescribimos estas dos ecuaciones, tenemos que $x\geq 0$ debe satisfacer ($A$ es simétrica):
$$A^t x = \lambda x,$$

es decir, $x$ es un vector propio de la matriz de adyacencia con valor propio positivo.

Sin embargo, ¿cuando existe un vector $x\geq 0$ con $\lambda>0$ que satisfaga esta propiedad?

#### Ejercicio {-}
Resuelve el sistema de ecuaciones de arriba y verifica que tal vector existe.
¿Cuál es el valor de lambda?



### Perron Frobenius: Centralidad de eigenvector 


```{block2, type='resumen'}
**Espectro de matrices no-negativas**

Si $A$ es una matriz no negativa,  entonces:

- Existe un valor
propio real *no-negativo* $\lambda_0$ tal que $\lambda_0\geq |\lambda|$ para cualquier otro valor propio $\lambda$ de $A$. 
- Al valor propio $\lambda_0$ está asociado a un vector propio $x$ con entradas no negativas. 
```

Si este vector propio no-negativo fuera único (hasta normalización), entonces esto nos daría un conjunto de medidas (únicas hasta normalización) $x$ para la importancia de los nodos:

### Ejemplo 1

```{r fig.width=4}
par(mar=c(0,0,0,0)); plot(red_6, vertex.size=40)
A_red <- igraph::get.adjacency(red_6)
A_red
```


```{r}
desc_A <- eigen(A_red)
desc_A
```

Las medida de centralidad da entonces, en este caso:

```{r, dev='pdf', fig.width=2, fig.height=1}
x <- desc_A$vectors[,1]
x
par(mar=c(0,0,0,0)); plot(red_6, vertex.size  = 100*x)
```


#### Ejemplo 2 {-}

Sin embargo, puede ser que obtengamos más de un valor propio no negativo con
vectores asociados no negativos, por ejemplo:


```{r, dev='pdf', fig.width=2, fig.height=1, message=FALSE}
red <- igraph::graph(c(1,2,2,3,3,1,2,4,5,6), directed = FALSE)
par(mar=c(0,0,0,0)); plot(red, vertex.size=50)
A_red <- igraph::get.adjacency(red)
A_red
```


Nótese que los eigenvectores 1 y 2 son positivos, y están asociados a 
vectores propios no negativos:
```{r}
desc_A <- eigen(A_red)
desc_A
```

En este caso, la medida de centralización dependería de qué
peso le ponemos al primer vector propio vs el segundo vector propio. En este
ejemplo, la unicidad no sucede pues la red asociado no es conexa.

### Matrices irreducibles y gráficas fuertemente conexas

¿Cuándo podemos garantizar unicidad en la solución de $Ax=\lambda x$ con $\lambda >0?$.

Sea $A$ la matriz de adyacencia de una gráfica no dirigida.
  
-  Si la gráfica asociada a $A$ es fuertemente conexa (existen caminos entre cualquier par de vértices) entonces decimos que $A$ es **irreducible**.
- Podemos dar también una definición de irreducibilidad sólo en términos
de $A$: $A$ es irreducible cuando para toda $i,j$ existe $m\geq 0$ tal
que $(A^m)_{i,j} > 0$.


```{block2, type='resumen'}
**Teorema de Perron-Frobenius**
  
Si $A$ es una matriz no-negativa irreducible, entonces

- Existe un valor
propio real *no-negativo* $\lambda_0$ tal que $\lambda_0 \geq |\lambda|$ para cualquier otro valor propio $\lambda$ de $A$, asociado a un vector propio $x$ con entradas positivas.
- No existe ningún otro vector propio con entradas no negativas que no sea paralelo a $x$.
```

Y entonces podemos definir una medida única de centralidad módulo una constante multiplicativa.

```{block2, type="resumen"}
Si $A$ es la matriz de adyacencia de una red no dirigida, y $A$ es irreducible (significa que la red es fuertemente conexa), definimos
la **centralidad de eigenvector** de un nodo $i$ como la $i$-esima componente
del vector positivo $x$ (con $\sum x_i = 1$)
asociado al valor propio (único) de Perron-Frobenius. 
```

#### Ejemplo: facultad de tres universidades {-}

```{r}
install.packages('igraphdata')
library("igraphdata")
data("UKfaculty")
ukf.und <- igraph::as.undirected(UKfaculty) 
head(dat.1 <- igraph::get.data.frame((ukf.und)))
dat.1$from <- dat.1$from 
dat.1$to <- dat.1$to
grupo <- igraph::get.vertex.attribute(UKfaculty, 'Group')
nodos <- data.frame(id=1:length(grupo))

visNetwork(nodos, dat.1, width = "100%") %>%
  visPhysics(solver ='forceAtlas2Based', 
             forceAtlas2Based = list(gravitationalConstant = -10),
             stabilization = TRUE)
```



Ahora calculamos centralidad de eigenvector.

```{r, fig.width=5, fig.asp=0.7}
A <- igraph::get.adjacency(ukf.und)
e.A <- eigen(as.matrix(A))
vec <- as.numeric(e.A$vector[,1])
e.A$values[1]
qplot(vec, binwidth = 0.01)
```

```{r}
e_vector <- -vec
colores <- colorRampPalette(c('red','green'))
colores_1 <- colores(length(e_vector))
nodos <- data.frame(id=1:length(vec), value = e_vector, 
                    color = colores_1[rank(e_vector)])

visNetwork(nodos, dat.1 %>% select(-weight), 
           width = "100%") %>%
  visPhysics(solver ='forceAtlas2Based', 
             stabilization = TRUE) %>%
  visNodes(value = 1, scaling = list(min = 1, max = 200))
```





### Ejercicio {#ejemplo}

Usa Gephi para calcular la centralidad de eigenvector/betweeness de tu red de amigos (es no dirigida).

- Bajar tu red: http://snacourse.com/getnet
- Gephi: https://gephi.org




### Gráficas dirigidas

Estos conceptos pueden generalizarse para gráficas dirigidas, cuando hay un concepto de dirección en las relaciones de los nodos.

- In degree, out degree
- Betweenness puede definirse en función de caminos dirigidos.
- Cercanía también (in closeness, out closeness)
- Centralidad de eigenvector: misma idea, pero la matriz $A$ no es simétrica.

Consideremos en particular cómo se calcula la centralidad de eigenvector para una red dirigida.

```{r, fig.height=3, fig.width=3, dev='pdf'}
set.seed(2801)
red.6 <- igraph::erdos.renyi.game(5, p.or.m=0.5, directed=T)
par(mar=c(0,0,0,0))
plot(red.6, vertex.size=40)
```

Su matriz de adyacencia es no simétrica
```{r}
A <- igraph::get.adjacency(red.6)
A
```

```{r}
centralidad <- igraph::evcent(red.6, directed = T)
centralidad$vector
```

Para este ejemplo, las ecuaciones de importancia son como sigue. Para el nodo 1,
$$\lambda x_1 = x_4 + x_2$$
para el nodo 5, por ejemplo, es
$$\lambda x_5 = x_4 + x_2 + x_3$$
y así sucesivamente.

Obsérvese que en cada ecuación se consideran las aristas *entrantes*, de forma que la ecuación del nodo 1 requiere la columna 1 de la matriz de adyacencia, el nodo 2 la columna 2, etc. Es decir, la ecuación que debemos resolver es

$$A^t x = \lambda x$$

En el ejemplo anterior,
```{r}
v.salida <- as.numeric(eigen(t(as.matrix(A)))$vectors[,1])
-v.salida/(sum(-v.salida))
```


### Perron Frobenius: 

¿Cuándo podemos garantizar unicidad en la solución de $A^tx=\lambda x$ con $\lambda > 0$.
Sea $A$ la matriz de adyacencia de una gráfica dirigida.

-  Si la gráfica asociada a $A$ es fuertemente conexa (para cualquier par de vértices hay caminos $i\to j$ y $j\to i$) entonces decimos que $A$ es **irreducible**.

- Si $A$ es irreducible, entonces $\lambda_0 > 0$ es un eigenvector simple de A, un vector propio asociado $x$ tiene entradas positivas, y no existe ningún otro vector propio con entradas no negativas que no sea paralelo a $x$

- Podemos definir una medida única de centralidad módulo una constante multiplicativa.


### Ejemplo: $A$ no irreducible {#ejemplo}

En este caso podemos no tener vectores propios no positivos (ponen
peso 0 en algunos nodos), cuando no es fuertemente conexa:

```{r}
red <- igraph::graph(c(1,2,2,3,3,4,4,3), directed = TRUE)
par(mar=c(0,0,0,0)); plot(red, vertex.size=50)
A.red <- as.matrix(igraph::get.adjacency(red))
A.red
eigen(t(A.red))
```

Podemos tener valores propios no simples con distintos
vectores propios no negativos (disconexa):

```{r}
red <- igraph::graph(c(1,2,2,3,3,1,4,5,5,4), directed = TRUE)
par(mar=c(0,0,0,0)); plot(red, vertex.size=50)
A.red <- as.matrix(igraph::get.adjacency(red))
A.red
eigen(t(A.red))
```

O ningún valor propio positivo:
```{r}
red <- igraph::graph(c(1,2,2,3), directed = TRUE)
par(mar=c(0,0,0,0)); plot(red, vertex.size=50)
A.red <- as.matrix(igraph::get.adjacency(red))
A.red
eigen(t(A.red))
```



## Pagerank
